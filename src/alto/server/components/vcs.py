# -*- coding: utf-8 -*-
# The MIT License (MIT)
#
# Copyright (c) 2023 OpenALTO Community
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Authors:
# - Jensen Zhang <jingxuan.n.zhang@gmail.com>

import hashlib
import json
import time
from threading import Event, Thread
from urllib.parse import urljoin

import json_merge_patch
import jsonpatch
import requests
from kazoo.client import KazooClient

from alto.config import Config
from alto.common.constants import ALTO_PARAMETER_TYPES, Diff


class VersionControl:
    """
    Version control system for ALTO information resources.
    """

    def __init__(self) -> None:
        self.config = Config()
        self.zk_host = self.config.get_vcs_zookeeper_host()
        self.zk_timeout = self.config.get_vcs_zookeeper_timeout()
        self.polling_interval = self.config.get_vcs_polling_interval()
        self.snapshot_freq = self.config.get_vcs_snapshot_freq()
        self.init_version = self.config.get_vcs_init_version()
        self.zk = KazooClient(hosts=self.zk_host)
        self.zk.start(timeout=self.zk_timeout)
        self.zk.ensure_path('/alto')
        self.subscribers = dict()


    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super(VersionControl, cls).__new__(cls)
        return cls.instance

    
    def __del__(self):
        self.stop()

    
    def stop(self):
        """
        Stop the version control system.
        """
        for listener in self.subscribers.values():
            listener.stop()
            listener.join()
        self.subscribers.clear()
        self.zk.stop()


    def subscribe(self, resource_id, request_body=None, client_id='public',
                  diff_format: Diff=Diff.JSON_MERGE_PATCH):
        """
        Subscribe an ALTO information resource to track future updates.

        Parameters
        ----------
        resource_id : str
            Resource ID of the subscribed information resource
        request_body : dict or None
            Optional request body to request the information resource. Set to
            None if the information resource is in GET mode. (default None)
        client_id : str
            ID of the client submitting this subscription
        diff_format : Diff
            Format of the diff patches generated by the updater

        Returns
        -------
        digest : str
            The digest token of the subscribed update listenser. If None, the
            subscription failed.
        """
        # Check if resource exists
        resources = self.config.get_configured_resources()
        resource = resources.get(resource_id)
        if resource is None:
            return None
        
        # Safely create dir for the resource
        self.zk.ensure_path('/alto/{}'.format(resource_id))
        request_body_enc, digest = get_request_digest(request_body, diff_format=diff_format)

        path = '/alto/{}/{}'.format(resource_id, digest)
        self.zk.ensure_path('{}/subscriber'.format(path))
        self.zk.create('{}/subscriber/{}'.format(path, client_id), b'')
        
        # check if resource has already been subscribed by another client
        if (resource_id, digest) not in self.subscribers:
            resource_listener = ResourceListener(self, path, resource_id, resource,
                                                 request_body=request_body,
                                                 polling_interval=self.polling_interval,
                                                 snapshot_freq=self.snapshot_freq,
                                                 init_ver=self.init_version,
                                                 diff_format=diff_format)
            if not resource_listener.success:
                return None
            self.subscribers[(resource_id, digest)] = resource_listener
            resource_listener.start()

        return digest


    def unsubscribe(self, resource_id, digest, client_id='public'):
        """
        Unsubscribe an update listener of an ALTO information resource.

        Parameters
        ----------
        resource_id : str
            Resource ID of the subscribed information resource
        digest : str
            The digest token of a subscribed update listenser.
        """
        try:
            path = '/alto/{}/{}'.format(resource_id, digest)
            path_subscriber = '{}/subscriber'.format(path)
            self.zk.delete('{}/{}'.format(path_subscriber, client_id))

            # if all the clients have unsubscribed the resource, remove listener
            active_subscribers = self.zk.get_children(path_subscriber)
            if not active_subscribers:
                listener = self.subscribers[(resource_id, digest)]
                listener.stop()
                listener.join()
                self.zk.delete('/alto/{}/{}'.format(resource_id, digest), recursive=True)
                del self.subscribers[(resource_id, digest)]
        except Exception:
            return False

        return True


    def get_tips_view(self, resource_id, digest):
        """
        Get available update graph.
        """
        ug = dict()
        ug_path = '/alto/{}/{}/ug'.format(resource_id, digest)
        start_seqs = sorted(self.zk.get_children(ug_path))
        for start_seq in start_seqs:
            ug[start_seq] = sorted(self.zk.get_children('{}/{}'.format(ug_path, start_seq)))
        return ug


    def show_tips_view(self, resource_id, digest):
        ug = self.get_tips_view(resource_id, digest)
        ug_path = '/alto/{}/{}/ug'.format(resource_id, digest)
        print(ug_path)
        for start_seq in sorted(ug.keys()):
            print(' ' * len(ug_path) + '%4d' % int(start_seq))
            for end_seq in ug[start_seq]:
                print(' ' * (len(ug_path)+5) + '%4d' % int(end_seq))


    def get_tips_data(self, resource_id, digest, start_seq, end_seq):
        """
        Get update data from start_seq to end_seq in an update graph.
        """
        try:
            data, stat = self.zk.get('/alto/{}/{}/ug/{}/{}'.format(resource_id, digest, start_seq, end_seq))
        except Exception:
            return None
        return data


vcs_singleton = VersionControl()


def get_resource(ctx: VersionControl, resource_id, resource, request_body=None):
    """
    Get ALTO response of an information resource.

    Parameters
    ----------
    ctx : VersionControl
        Context of the version control system
    resource_id : str
        Resource ID
    resource : dict
        Metadata of the information resource
    request_body : dict | None
        Request body to query the information resource

    Returns
    -------
    response : bytes or None
        The content of the query response. If None, the request failed.
    """
    base_uri = ctx.config.get_server_base_uri()
    resource_path = resource.get('path')
    url = urljoin(base_uri, '{}/{}'.format(resource_path, resource_id))
    resource_type = resource.get('type')
    kwargs = dict()

    auth = ctx.config.get_server_auth()
    kwargs['auth'] = auth

    if resource_type == 'ird':
        method = 'GET'
    elif resource_type == 'network-map':
        method = 'GET'
    elif resource_type == 'cost-map':
        method = 'GET'
    elif resource_type == 'filtered-network-map':
        method = 'POST'
    elif resource_type == 'filtered-cost-map':
        method = 'POST'
    elif resource_type == 'endpoint-cost':
        method = 'POST'
    elif resource_type == 'endpoint-prop':
        method = 'POST'
    elif resource_type == 'entity-prop':
        method = 'POST'
    elif resource_type == 'path-vector':
        method = 'POST'

    if method == 'POST':
        kwargs['json'] = request_body
        kwargs['headers'] = {
            'content-type': ALTO_PARAMETER_TYPES.get(resource_type)
        }
    res = requests.request(method, url, **kwargs)
    if res.status_code == 200:
        return res.content
    else:
        return None


def get_request_digest(request_body, diff_format: Diff=Diff.JSON_MERGE_PATCH):
    request_body_enc = b''
    if request_body:
        request_body_enc = json.dumps(request_body, sort_keys=True).encode()
    m = hashlib.md5()
    m.update(diff_format.value.to_bytes(1, 'little'))
    m.update(request_body_enc)
    digest = m.hexdigest()
    return request_body_enc, digest


class ResourceListener(Thread):

    def __init__(self, ctx: VersionControl, path, resource_id, resource,
                 request_body=None, polling_interval=1, snapshot_freq=3,
                 init_ver=1, diff_format: Diff=Diff.JSON_MERGE_PATCH) -> None:
        self.ctx = ctx
        self.path = path
        self.resource_id = resource_id
        self.resource = resource
        self.request_body = request_body
        self.stop_event = Event()
        self.polling_interval = polling_interval
        self.snapshot_freq = snapshot_freq
        self.diff_format = diff_format
        self.success = self.initialize(init_ver)
        super().__init__()


    def initialize(self, init_ver):
        raw_last_res = get_resource(self.ctx, self.resource_id, self.resource, self.request_body)
        if raw_last_res is None:
            return False
        self.ctx.zk.ensure_path('{}/ug/0'.format(self.path))
        self.ctx.zk.create('{}/ug/0/{}'.format(self.path, init_ver), raw_last_res)
        self.last_res = json.loads(raw_last_res)
        self.init_ver = init_ver
        self.last_ver = init_ver
        return True

    
    def run(self):
        self.ctx.zk.ensure_path('{}/ug/0'.format(self.path))
        while not self.stop_event.is_set():
            time.sleep(self.polling_interval)
            raw_res = get_resource(self.ctx, self.resource_id, self.resource, self.request_body)
            if raw_res is None:
                continue
            res = json.loads(raw_res)
            patch = self.create_patch(self.last_res, res)
            if patch:
                self.last_res = res
                self.ctx.zk.ensure_path('{}/ug/{}'.format(self.path, self.last_ver))
                new_ver = self.last_ver + 1
                self.ctx.zk.create('{}/ug/{}/{}'.format(self.path, self.last_ver, new_ver),
                                   json.dumps(patch).encode())
                self.last_ver = new_ver
                if (self.last_ver - self.init_ver) % self.snapshot_freq == 0:
                    self.ctx.zk.create('{}/ug/0/{}'.format(self.path, self.last_ver), raw_res)


    def create_patch(self, old, new):
        patch = new
        if self.diff_format == Diff.JSON_PATCH:
            patch = jsonpatch.JsonPatch.from_diff(old, new).patch
        elif self.diff_format == Diff.JSON_MERGE_PATCH:
            patch = json_merge_patch.create_patch(old, new)
        return patch


    def stop(self):
        self.stop_event.set()
